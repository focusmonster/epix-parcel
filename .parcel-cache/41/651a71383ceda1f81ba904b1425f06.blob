import   "c99b3a7ddad5b4727bb09d9c8ca7cea6:react";
import   "c99b3a7ddad5b4727bb09d9c8ca7cea6:react-dom";
var $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadKeyboardEvent = true;
var $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecently = false;
var $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecentlyTimeout = null;
var $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @return {boolean}
 */ function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$focusTriggersKeyboardModality(node) {
    var type = node.type, tagName = node.tagName;
    if (tagName === 'INPUT' && $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$inputTypesWhitelist[type] && !node.readOnly) return true;
    if (tagName === 'TEXTAREA' && !node.readOnly) return true;
    if (node.isContentEditable) return true;
    return false;
}
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */ function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) return;
    $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */ function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown() {
    $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadKeyboardEvent = false;
}
function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleVisibilityChange() {
    if (this.visibilityState === 'hidden') // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    {
        if ($c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecently) $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadKeyboardEvent = true;
    }
}
function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$prepare(doc) {
    doc.addEventListener('keydown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleKeyDown, true);
    doc.addEventListener('mousedown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.addEventListener('pointerdown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.addEventListener('touchstart', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.addEventListener('visibilitychange', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleVisibilityChange, true);
}
function $c99b3a7ddad5b4727bb09d9c8ca7cea6$export$1e4b90beda3567d0(doc) {
    doc.removeEventListener('keydown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleKeyDown, true);
    doc.removeEventListener('mousedown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.removeEventListener('pointerdown', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.removeEventListener('touchstart', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handlePointerDown, true);
    doc.removeEventListener('visibilitychange', $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleVisibilityChange, true);
}
function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$isFocusVisible(event) {
    var target = event.target;
    try {
        return target.matches(':focus-visible');
    } catch (error) {
    } // browsers not implementing :focus-visible will throw a SyntaxError
    // we use our own heuristic for those browsers
    // rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
    // no need for validFocusTarget check. the user does that by attaching it to
    // focusable events only
    return $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadKeyboardEvent || $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$focusTriggersKeyboardModality(target);
}
/**
 * Should be called if a blur event is fired on a focus-visible element
 */ function $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleBlurVisible() {
    // To detect a tab/window switch, we look for a blur event followed
    // rapidly by a visibility change.
    // If we don't see a visibility change within 100ms, it's probably a
    // regular focus change.
    $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecently = true;
    window.clearTimeout($c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecentlyTimeout);
    $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
        $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$hadFocusVisibleRecently = false;
    }, 100);
}
function $c99b3a7ddad5b4727bb09d9c8ca7cea6$export$9099ad97b570f7c() {
    var ref = $c99b3a7ddad5b4727bb09d9c8ca7cea6$import$f02ba03fc070e88c$e04575e0186a275b(function(instance) {
        var node = $c99b3a7ddad5b4727bb09d9c8ca7cea6$import$9c1aa63963514e3e$1817be7fffc127f2(instance);
        if (node != null) $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$prepare(node.ownerDocument);
    }, []);
    return {
        isFocusVisible: $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$isFocusVisible,
        onBlurVisible: $c99b3a7ddad5b4727bb09d9c8ca7cea6$var$handleBlurVisible,
        ref: ref
    };
}
