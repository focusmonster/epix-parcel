import   "1114e04e4448499c25816440e1d200d1:@babel/runtime/helpers/esm/classCallCheck";
import   "1114e04e4448499c25816440e1d200d1:@babel/runtime/helpers/esm/createClass";
import   "1114e04e4448499c25816440e1d200d1:@babel/runtime/helpers/esm/toConsumableArray";
import   "1114e04e4448499c25816440e1d200d1:../utils/getScrollbarSize";
import   "1114e04e4448499c25816440e1d200d1:../utils/ownerDocument";
import   "1114e04e4448499c25816440e1d200d1:../utils/ownerWindow";
function $1114e04e4448499c25816440e1d200d1$var$isOverflowing(container) {
    var doc = $1114e04e4448499c25816440e1d200d1$import$bc270da7a301e7e$9099ad97b570f7c(container);
    if (doc.body === container) return $1114e04e4448499c25816440e1d200d1$import$556b2e6b7545616a$9099ad97b570f7c(doc).innerWidth > doc.documentElement.clientWidth;
    return container.scrollHeight > container.clientHeight;
}
function $1114e04e4448499c25816440e1d200d1$export$15c75a17b4ef94e3(node, show) {
    if (show) node.setAttribute('aria-hidden', 'true');
    else node.removeAttribute('aria-hidden');
}
function $1114e04e4448499c25816440e1d200d1$var$getPaddingRight(node) {
    return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
}
function $1114e04e4448499c25816440e1d200d1$var$ariaHiddenSiblings(container, mountNode, currentNode) {
    var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var show = arguments.length > 4 ? arguments[4] : undefined;
    var blacklist = [
        mountNode,
        currentNode
    ].concat($1114e04e4448499c25816440e1d200d1$import$4d3a86197f512b9$9099ad97b570f7c(nodesToExclude));
    var blacklistTagNames = [
        'TEMPLATE',
        'SCRIPT',
        'STYLE'
    ];
    [].forEach.call(container.children, function(node) {
        if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) $1114e04e4448499c25816440e1d200d1$export$15c75a17b4ef94e3(node, show);
    });
}
function $1114e04e4448499c25816440e1d200d1$var$findIndexOf(containerInfo, callback) {
    var idx = -1;
    containerInfo.some(function(item, index) {
        if (callback(item)) {
            idx = index;
            return true;
        }
        return false;
    });
    return idx;
}
function $1114e04e4448499c25816440e1d200d1$var$handleContainer(containerInfo, props) {
    var restoreStyle = [];
    var restorePaddings = [];
    var container = containerInfo.container;
    var fixedNodes;
    if (!props.disableScrollLock) {
        if ($1114e04e4448499c25816440e1d200d1$var$isOverflowing(container)) {
            // Compute the size before applying overflow hidden to avoid any scroll jumps.
            var scrollbarSize = $1114e04e4448499c25816440e1d200d1$import$d91c458c03c8226e$9099ad97b570f7c();
            restoreStyle.push({
                value: container.style.paddingRight,
                key: 'padding-right',
                el: container
            }); // Use computed style, here to get the real padding to add our scrollbar width.
            container.style['padding-right'] = "".concat($1114e04e4448499c25816440e1d200d1$var$getPaddingRight(container) + scrollbarSize, "px"); // .mui-fixed is a global helper.
            fixedNodes = $1114e04e4448499c25816440e1d200d1$import$bc270da7a301e7e$9099ad97b570f7c(container).querySelectorAll('.mui-fixed');
            [].forEach.call(fixedNodes, function(node) {
                restorePaddings.push(node.style.paddingRight);
                node.style.paddingRight = "".concat($1114e04e4448499c25816440e1d200d1$var$getPaddingRight(node) + scrollbarSize, "px");
            });
        } // Improve Gatsby support
        // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
        var parent = container.parentElement;
        var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
        // screensize shrink.
        restoreStyle.push({
            value: scrollContainer.style.overflow,
            key: 'overflow',
            el: scrollContainer
        });
        scrollContainer.style.overflow = 'hidden';
    }
    var restore = function restore1() {
        if (fixedNodes) [].forEach.call(fixedNodes, function(node, i) {
            if (restorePaddings[i]) node.style.paddingRight = restorePaddings[i];
            else node.style.removeProperty('padding-right');
        });
        restoreStyle.forEach(function(_ref) {
            var value = _ref.value, el = _ref.el, key = _ref.key;
            if (value) el.style.setProperty(key, value);
            else el.style.removeProperty(key);
        });
    };
    return restore;
}
function $1114e04e4448499c25816440e1d200d1$var$getHiddenSiblings(container) {
    var hiddenSiblings = [];
    [].forEach.call(container.children, function(node) {
        if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') hiddenSiblings.push(node);
    });
    return hiddenSiblings;
}
/**
 * @ignore - do not document.
 *
 * Proper state management for containers and the modals in those containers.
 * Simplified, but inspired by react-overlay's ModalManager class.
 * Used by the Modal to ensure proper styling of containers.
 */ var $1114e04e4448499c25816440e1d200d1$export$9099ad97b570f7c = /*#__PURE__*/ function() {
    function ModalManager() {
        $1114e04e4448499c25816440e1d200d1$import$4466a94fade54de4$9099ad97b570f7c(this, ModalManager);
        // this.modals[modalIndex] = modal
        this.modals = []; // this.containers[containerIndex] = {
        //   modals: [],
        //   container,
        //   restore: null,
        // }
        this.containers = [];
    }
    $1114e04e4448499c25816440e1d200d1$import$b6c835cc85dadee3$9099ad97b570f7c(ModalManager, [
        {
            key: "add",
            value: function add(modal, container) {
                var modalIndex = this.modals.indexOf(modal);
                if (modalIndex !== -1) return modalIndex;
                modalIndex = this.modals.length;
                this.modals.push(modal); // If the modal we are adding is already in the DOM.
                if (modal.modalRef) $1114e04e4448499c25816440e1d200d1$export$15c75a17b4ef94e3(modal.modalRef, false);
                var hiddenSiblingNodes = $1114e04e4448499c25816440e1d200d1$var$getHiddenSiblings(container);
                $1114e04e4448499c25816440e1d200d1$var$ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
                var containerIndex = $1114e04e4448499c25816440e1d200d1$var$findIndexOf(this.containers, function(item) {
                    return item.container === container;
                });
                if (containerIndex !== -1) {
                    this.containers[containerIndex].modals.push(modal);
                    return modalIndex;
                }
                this.containers.push({
                    modals: [
                        modal
                    ],
                    container: container,
                    restore: null,
                    hiddenSiblingNodes: hiddenSiblingNodes
                });
                return modalIndex;
            }
        },
        {
            key: "mount",
            value: function mount(modal, props) {
                var containerIndex = $1114e04e4448499c25816440e1d200d1$var$findIndexOf(this.containers, function(item) {
                    return item.modals.indexOf(modal) !== -1;
                });
                var containerInfo = this.containers[containerIndex];
                if (!containerInfo.restore) containerInfo.restore = $1114e04e4448499c25816440e1d200d1$var$handleContainer(containerInfo, props);
            }
        },
        {
            key: "remove",
            value: function remove(modal) {
                var modalIndex = this.modals.indexOf(modal);
                if (modalIndex === -1) return modalIndex;
                var containerIndex = $1114e04e4448499c25816440e1d200d1$var$findIndexOf(this.containers, function(item) {
                    return item.modals.indexOf(modal) !== -1;
                });
                var containerInfo = this.containers[containerIndex];
                containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
                this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.
                if (containerInfo.modals.length === 0) {
                    // The modal might be closed before it had the chance to be mounted in the DOM.
                    if (containerInfo.restore) containerInfo.restore();
                    if (modal.modalRef) // In case the modal wasn't in the DOM yet.
                    $1114e04e4448499c25816440e1d200d1$export$15c75a17b4ef94e3(modal.modalRef, true);
                    $1114e04e4448499c25816440e1d200d1$var$ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
                    this.containers.splice(containerIndex, 1);
                } else {
                    // Otherwise make sure the next top modal is visible to a screen reader.
                    var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
                    // aria-hidden because the dom element doesn't exist either
                    // when modal was unmounted before modalRef gets null
                    if (nextTop.modalRef) $1114e04e4448499c25816440e1d200d1$export$15c75a17b4ef94e3(nextTop.modalRef, false);
                }
                return modalIndex;
            }
        },
        {
            key: "isTopModal",
            value: function isTopModal(modal) {
                return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
            }
        }
    ]);
    return ModalManager;
}();
